<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Convolution Visualizer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        
        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }
        
        .play-btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
        }
        
        .pause-btn {
            background: linear-gradient(45deg, #f44336, #da190b);
            color: white;
        }
        
        .reset-btn {
            background: linear-gradient(45deg, #2196F3, #0b7dda);
            color: white;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .function-selector {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        select {
            padding: 8px 12px;
            border-radius: 5px;
            border: 2px solid #ddd;
            font-size: 14px;
        }
        
        .canvas-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }
        
        canvas {
            border: 2px solid #333;
            border-radius: 10px;
            background: white;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .info {
            text-align: center;
            color: #666;
            font-size: 14px;
            margin-top: 20px;
        }
        
        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        input[type="range"] {
            width: 120px;
        }
        
        input[type="text"] {
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 12px;
            width: 150px;
        }
        
        .error-msg {
            color: #ff4444;
            font-size: 12px;
            margin-top: 5px;
        }
        
        .examples {
            background: rgba(240, 248, 255, 0.8);
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            font-size: 14px;
        }
        
        .examples h3 {
            margin-top: 0;
            color: #333;
        }
        
        .examples code {
            background: rgba(0, 100, 200, 0.1);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Convolution Operation</h1>
        
        <div class="controls">
            <div class="function-selector">
                <label>Function 1:</label>
                <select id="func1">
                    <option value="gaussian">Gaussian</option>
                    <option value="rect">Rectangle</option>
                    <option value="triangle">Triangle</option>
                    <option value="sine">Sine Wave</option>
                    <option value="custom1">Custom</option>
                </select>
                <input type="text" id="custom1Input" placeholder="e.g., exp(-x*x)" style="display:none; margin-left: 5px; padding: 5px;">
            </div>
            
            <div class="function-selector">
                <label>Function 2:</label>
                <select id="func2">
                    <option value="rect">Rectangle</option>
                    <option value="gaussian">Gaussian</option>
                    <option value="triangle">Triangle</option>
                    <option value="sine">Sine Wave</option>
                    <option value="custom2">Custom</option>
                </select>
                <input type="text" id="custom2Input" placeholder="e.g., sin(x)" style="display:none; margin-left: 5px; padding: 5px;">
            </div>
            
            <div class="speed-control">
                <label>Speed:</label>
                <input type="range" id="speedSlider" min="0.5" max="3" value="1" step="0.1">
                <span id="speedValue">1x</span>
            </div>
            
            <button id="playBtn" class="play-btn">‚ñ∂ Play</button>
            <button id="pauseBtn" class="pause-btn">‚è∏ Pause</button>
            <button id="resetBtn" class="reset-btn">üîÑ Reset</button>
        </div>
        
        <div class="canvas-container">
            <canvas id="convolutionCanvas" width="800" height="200"></canvas>
            <canvas id="overlayCanvas" width="800" height="300"></canvas>
        </div>
        
        <div class="info">
            <p>The top plot shows the convolution result being built in real-time.</p>
            <p>The bottom plot shows the original functions and the moving flipped kernel.</p>
            <p> Reset before playing Again</p>
        </div>
        
        <div class="examples">
            <h3>Custom Function Examples:</h3>
            <p><strong>Mathematical functions you can use:</strong></p>
            <p>
                <code>sin(x)</code>, <code>cos(x)</code>, <code>tan(x)</code> - Trigonometric functions<br>
                <code>exp(x)</code> - Exponential function<br>
                <code>log(x)</code> - Natural logarithm<br>
                <code>abs(x)</code> - Absolute value<br>
                <code>sqrt(x)</code> - Square root<br>
                <code>x*x</code> - x squared<br>
                <code>pow(x, n)</code> - x to the power of n<br>
                <code>max(0, 1-abs(x))</code> - Triangle function<br>
                <code>x > -1 && x < 1 ? 1 : 0</code> - Rectangle using conditionals<br>
                <code>exp(-x*x/2)</code> - Gaussian function
            </p>
            <div id="errorMsg" class="error-msg"></div>
        </div>
    </div>

    <script>
        class ConvolutionVisualizer {
            constructor() {
                this.convCanvas = document.getElementById('convolutionCanvas');
                this.convCtx = this.convCanvas.getContext('2d');
                this.overlayCanvas = document.getElementById('overlayCanvas');
                this.overlayCtx = this.overlayCanvas.getContext('2d');
                
                this.width = 800;
                this.height1 = 200;
                this.height2 = 300;
                
                this.xMin = -5;
                this.xMax = 5;
                this.samples = 200;
                this.dx = (this.xMax - this.xMin) / this.samples;
                
                this.currentT = this.xMin;
                this.convolutionResult = [];
                this.tValues = [];
                
                this.isPlaying = false;
                this.animationId = null;
                this.speed = 1;
                
                this.customFunction1 = '';
                this.customFunction2 = '';
                this.errorMsg = document.getElementById('errorMsg');
                
                this.setupEventListeners();
                this.reset();
            }
            
            setupEventListeners() {
                document.getElementById('playBtn').addEventListener('click', () => this.play());
                document.getElementById('pauseBtn').addEventListener('click', () => this.pause());
                document.getElementById('resetBtn').addEventListener('click', () => this.reset());
                
                const func1Select = document.getElementById('func1');
                const func2Select = document.getElementById('func2');
                const custom1Input = document.getElementById('custom1Input');
                const custom2Input = document.getElementById('custom2Input');
                
                func1Select.addEventListener('change', (e) => {
                    if (e.target.value === 'custom1') {
                        custom1Input.style.display = 'inline-block';
                        custom1Input.focus();
                    } else {
                        custom1Input.style.display = 'none';
                    }
                    this.reset();
                });
                
                func2Select.addEventListener('change', (e) => {
                    if (e.target.value === 'custom2') {
                        custom2Input.style.display = 'inline-block';
                        custom2Input.focus();
                    } else {
                        custom2Input.style.display = 'none';
                    }
                    this.reset();
                });
                
                custom1Input.addEventListener('input', (e) => {
                    this.customFunction1 = e.target.value;
                    this.validateCustomFunction(this.customFunction1);
                    this.reset();
                });
                
                custom2Input.addEventListener('input', (e) => {
                    this.customFunction2 = e.target.value;
                    this.validateCustomFunction(this.customFunction2);
                    this.reset();
                });
                
                const speedSlider = document.getElementById('speedSlider');
                speedSlider.addEventListener('input', (e) => {
                    this.speed = parseFloat(e.target.value);
                    document.getElementById('speedValue').textContent = this.speed + 'x';
                });
            }
            
            validateCustomFunction(funcStr) {
                this.errorMsg.textContent = '';
                if (!funcStr.trim()) return true;
                
                try {
                    // Test the function with a sample value
                    this.evaluateCustomFunction(funcStr, 1);
                    return true;
                } catch (error) {
                    this.errorMsg.textContent = `Error in custom function: ${error.message}`;
                    return false;
                }
            }
            
            evaluateCustomFunction(funcStr, x) {
                // Create a safe evaluation environment
                const safeEval = new Function('x', `
                    const sin = Math.sin;
                    const cos = Math.cos;
                    const tan = Math.tan;
                    const exp = Math.exp;
                    const log = Math.log;
                    const abs = Math.abs;
                    const sqrt = Math.sqrt;
                    const pow = Math.pow;
                    const max = Math.max;
                    const min = Math.min;
                    const PI = Math.PI;
                    const E = Math.E;
                    
                    try {
                        return ${funcStr};
                    } catch (e) {
                        throw new Error('Invalid expression: ' + e.message);
                    }
                `);
                
                const result = safeEval(x);
                return isFinite(result) ? result : 0;
            }
            
            getFunction(name, x) {
                switch(name) {
                    case 'gaussian':
                        return Math.exp(-x * x / 0.5);
                    case 'rect':
                        return Math.abs(x) <= 1 ? 1 : 0;
                    case 'triangle':
                        return Math.max(0, 1 - Math.abs(x));
                    case 'sine':
                        return Math.abs(x) <= 2 ? Math.sin(Math.PI * x / 2) : 0;
                    case 'custom1':
                        if (!this.customFunction1.trim()) return 0;
                        try {
                            return this.evaluateCustomFunction(this.customFunction1, x);
                        } catch (e) {
                            return 0;
                        }
                    case 'custom2':
                        if (!this.customFunction2.trim()) return 0;
                        try {
                            return this.evaluateCustomFunction(this.customFunction2, x);
                        } catch (e) {
                            return 0;
                        }
                    default:
                        return 0;
                }
            }
            
            xToCanvas(x, canvas) {
                return (x - this.xMin) / (this.xMax - this.xMin) * canvas.width;
            }
            
            yToCanvas(y, canvas, maxY = 1) {
                return canvas.height - (y / maxY) * (canvas.height - 40) - 20;
            }
            
            computeConvolutionPoint(t) {
                let sum = 0;
                for (let i = 0; i < this.samples; i++) {
                    const x = this.xMin + i * this.dx;
                    const f1Val = this.getFunction(document.getElementById('func1').value, x);
                    const f2Val = this.getFunction(document.getElementById('func2').value, t - x);
                    sum += f1Val * f2Val * this.dx;
                }
                return sum;
            }
            
            drawConvolutionPlot() {
                this.convCtx.clearRect(0, 0, this.width, this.height1);
                
                // Background
                this.convCtx.fillStyle = '#f8f9ff';
                this.convCtx.fillRect(0, 0, this.width, this.height1);
                
                // Grid
                this.convCtx.strokeStyle = '#e0e0e0';
                this.convCtx.lineWidth = 1;
                for (let i = 0; i <= 10; i++) {
                    const x = (i / 10) * this.width;
                    this.convCtx.beginPath();
                    this.convCtx.moveTo(x, 0);
                    this.convCtx.lineTo(x, this.height1);
                    this.convCtx.stroke();
                }
                
                // Title
                this.convCtx.fillStyle = '#333';
                this.convCtx.font = 'bold 16px Arial';
                this.convCtx.fillText('Convolution Result: (f‚ÇÅ * f‚ÇÇ)(t)', 10, 25);
                
                // Draw convolution result
                if (this.convolutionResult.length > 1) {
                    this.convCtx.strokeStyle = '#ff4444';
                    this.convCtx.lineWidth = 3;
                    this.convCtx.beginPath();
                    
                    for (let i = 0; i < this.convolutionResult.length; i++) {
                        const x = this.xToCanvas(this.tValues[i], this.convCanvas);
                        const y = this.yToCanvas(this.convolutionResult[i], this.convCanvas, 2);
                        
                        if (i === 0) {
                            this.convCtx.moveTo(x, y);
                        } else {
                            this.convCtx.lineTo(x, y);
                        }
                    }
                    this.convCtx.stroke();
                    
                    // Current point
                    if (this.convolutionResult.length > 0) {
                        const lastIdx = this.convolutionResult.length - 1;
                        const x = this.xToCanvas(this.tValues[lastIdx], this.convCanvas);
                        const y = this.yToCanvas(this.convolutionResult[lastIdx], this.convCanvas, 2);
                        
                        this.convCtx.fillStyle = '#ff0000';
                        this.convCtx.beginPath();
                        this.convCtx.arc(x, y, 6, 0, 2 * Math.PI);
                        this.convCtx.fill();
                    }
                }
                
                // Axes
                this.convCtx.strokeStyle = '#666';
                this.convCtx.lineWidth = 2;
                this.convCtx.beginPath();
                this.convCtx.moveTo(0, this.height1 - 20);
                this.convCtx.lineTo(this.width, this.height1 - 20);
                this.convCtx.stroke();
            }
            
            drawOverlayPlot() {
                this.overlayCtx.clearRect(0, 0, this.width, this.height2);
                
                // Background
                this.overlayCtx.fillStyle = '#f8f9ff';
                this.overlayCtx.fillRect(0, 0, this.width, this.height2);
                
                // Grid
                this.overlayCtx.strokeStyle = '#e0e0e0';
                this.overlayCtx.lineWidth = 1;
                for (let i = 0; i <= 10; i++) {
                    const x = (i / 10) * this.width;
                    this.overlayCtx.beginPath();
                    this.overlayCtx.moveTo(x, 0);
                    this.overlayCtx.lineTo(x, this.height2);
                    this.overlayCtx.stroke();
                }
                
                // Title
                this.overlayCtx.fillStyle = '#333';
                this.overlayCtx.font = 'bold 16px Arial';
                this.overlayCtx.fillText('Functions and Moving Kernel', 10, 25);
                
                // Draw function 1 (fixed)
                this.overlayCtx.strokeStyle = '#0066cc';
                this.overlayCtx.lineWidth = 3;
                this.overlayCtx.beginPath();
                
                for (let i = 0; i <= this.samples; i++) {
                    const x = this.xMin + i * this.dx;
                    const y = this.getFunction(document.getElementById('func1').value, x);
                    const canvasX = this.xToCanvas(x, this.overlayCanvas);
                    const canvasY = this.yToCanvas(y, this.overlayCanvas, 1.2);
                    
                    if (i === 0) {
                        this.overlayCtx.moveTo(canvasX, canvasY);
                    } else {
                        this.overlayCtx.lineTo(canvasX, canvasY);
                    }
                }
                this.overlayCtx.stroke();
                
                // Draw function 2 (flipped and shifted)
                this.overlayCtx.strokeStyle = '#cc6600';
                this.overlayCtx.lineWidth = 3;
                this.overlayCtx.beginPath();
                
                for (let i = 0; i <= this.samples; i++) {
                    const x = this.xMin + i * this.dx;
                    const y = this.getFunction(document.getElementById('func2').value, this.currentT - x);
                    const canvasX = this.xToCanvas(x, this.overlayCanvas);
                    const canvasY = this.yToCanvas(y, this.overlayCanvas, 1.2);
                    
                    if (i === 0) {
                        this.overlayCtx.moveTo(canvasX, canvasY);
                    } else {
                        this.overlayCtx.lineTo(canvasX, canvasY);
                    }
                }
                this.overlayCtx.stroke();
                
                // Draw product (highlighted area)
                this.overlayCtx.fillStyle = 'rgba(255, 0, 255, 0.2)';
                this.overlayCtx.beginPath();
                
                const baseY = this.yToCanvas(0, this.overlayCanvas, 1.2);
                this.overlayCtx.moveTo(0, baseY);
                
                for (let i = 0; i <= this.samples; i++) {
                    const x = this.xMin + i * this.dx;
                    const f1Val = this.getFunction(document.getElementById('func1').value, x);
                    const f2Val = this.getFunction(document.getElementById('func2').value, this.currentT - x);
                    const product = f1Val * f2Val;
                    
                    const canvasX = this.xToCanvas(x, this.overlayCanvas);
                    const canvasY = this.yToCanvas(product, this.overlayCanvas, 1.2);
                    this.overlayCtx.lineTo(canvasX, canvasY);
                }
                
                this.overlayCtx.lineTo(this.width, baseY);
                this.overlayCtx.closePath();
                this.overlayCtx.fill();
                
                // Current t indicator
                const tX = this.xToCanvas(this.currentT, this.overlayCanvas);
                this.overlayCtx.strokeStyle = '#ff0000';
                this.overlayCtx.lineWidth = 2;
                this.overlayCtx.setLineDash([5, 5]);
                this.overlayCtx.beginPath();
                this.overlayCtx.moveTo(tX, 0);
                this.overlayCtx.lineTo(tX, this.height2);
                this.overlayCtx.stroke();
                this.overlayCtx.setLineDash([]);
                
                // Axes and labels
                this.overlayCtx.strokeStyle = '#666';
                this.overlayCtx.lineWidth = 2;
                this.overlayCtx.beginPath();
                this.overlayCtx.moveTo(0, this.height2 - 20);
                this.overlayCtx.lineTo(this.width, this.height2 - 20);
                this.overlayCtx.stroke();
                
                // Legend
                this.overlayCtx.fillStyle = '#333';
                this.overlayCtx.font = '12px Arial';
                this.overlayCtx.fillStyle = '#0066cc';
                this.overlayCtx.fillText('f‚ÇÅ(x)', this.width - 150, 45);
                this.overlayCtx.fillStyle = '#cc6600';
                this.overlayCtx.fillText('f‚ÇÇ(t-x)', this.width - 90, 45);
                this.overlayCtx.fillStyle = '#ff00ff';
                this.overlayCtx.fillText('product', this.width - 150, 60);
                
                this.overlayCtx.fillStyle = '#333';
                this.overlayCtx.fillText(`t = ${this.currentT.toFixed(2)}`, this.width - 80, 75);
            }
            
            animate() {
                if (!this.isPlaying) return;
                
                this.currentT += 0.05 * this.speed;
                
                // Compute convolution value at current t
                const convValue = this.computeConvolutionPoint(this.currentT);
                this.convolutionResult.push(convValue);
                this.tValues.push(this.currentT);
                
                this.drawConvolutionPlot();
                this.drawOverlayPlot();
                
                if (this.currentT < this.xMax) {
                    this.animationId = requestAnimationFrame(() => this.animate());
                } else {
                    this.pause();
                }
            }
            
            play() {
                this.isPlaying = true;
                this.animate();
            }
            
            pause() {
                this.isPlaying = false;
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
            }
            
            reset() {
                this.pause();
                this.currentT = this.xMin;
                this.convolutionResult = [];
                this.tValues = [];
                this.drawConvolutionPlot();
                this.drawOverlayPlot();
            }
        }
        
        // Initialize the visualizer when the page loads
        window.addEventListener('load', () => {
            new ConvolutionVisualizer();
        });
    </script>
</body>
</html>